<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Personal Whiteboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables for Theming */
        :root {
            --bg-color: #f4f7fa;
            --container-bg: #ffffff;
            --toolbar-bg: #fdfdfd;
            --text-color: #2d3748;
            --text-color-light: #718096;
            --border-color: #e2e8f0;
            --button-bg: #ffffff;
            --button-border: #cbd5e0;
            --button-hover-bg: #f7fafc;
            --button-hover-border: #a0aec0;
            --button-active-bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --button-active-border: #667eea;
            --button-active-color: #ffffff;
            --canvas-bg: #ffffff;
            --input-bg: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.05);
            --gradient-start: #667eea;
            --gradient-end: #764ba2;
        }

        body.dark-mode {
            --bg-color: #1a202c;
            --container-bg: #2d3748;
            --toolbar-bg: #283141;
            --text-color: #e2e8f0;
            --text-color-light: #a0aec0;
            --border-color: #4a5568;
            --button-bg: #4a5568;
            --button-border: #718096;
            --button-hover-bg: #2d3748;
            --button-hover-border: #a0aec0;
            --button-active-bg: linear-gradient(135deg, #5a67d8 0%, #805ad5 100%);
            --button-active-border: #5a67d8;
            --button-active-color: #ffffff;
            --canvas-bg: #1A202C;
            --input-bg: #4a5568;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --gradient-start: #5a67d8;
            --gradient-end: #805ad5;
        }

        /* Basic Reset and Body Styling */
        body {
            font-family: 'Inter', sans-serif;
            background-image: linear-gradient(120deg, var(--bg-color) 0%, #eef2f7 100%);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }
        
        body.dark-mode {
             background-image: linear-gradient(120deg, var(--bg-color) 0%, #2d3748 100%);
        }

        .app-wrapper {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            align-items: flex-start;
        }

        /* Main Application Container */
        .whiteboard-container {
            flex-grow: 1;
            background-color: var(--container-bg);
            border-radius: 16px;
            box-shadow: 0 20px 40px var(--shadow-color);
            border: 1px solid var(--border-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        /* Toolbar Styling */
        .toolbar {
            padding: 12px 20px;
            background-color: var(--toolbar-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 15px;
            transition: background-color 0.3s, border-bottom-color 0.3s;
        }

        /* Styling for each tool group */
        .tool-group {
            display: flex;
            align-items: center;
            gap: 10px;
            border-right: 1px solid var(--border-color);
            padding-right: 15px;
        }
        .tool-group:last-child { border-right: none; padding-right: 0; }
        
        .tool-group label { font-size: 14px; font-weight: 500; color: var(--text-color-light); }
        
        .tool-button, .action-button, select {
            padding: 8px 12px; font-size: 14px; font-weight: 500; border: 1px solid var(--button-border);
            border-radius: 8px; background-color: var(--button-bg); color: var(--text-color);
            cursor: pointer; transition: all 0.2s ease-in-out; display: flex; align-items: center; gap: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        
        select { background-color: var(--input-bg); }
        .tool-button:disabled, .action-button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; transform: none; }
        .tool-button:hover:not(:disabled), .action-button:hover:not(:disabled), select:hover { background-color: var(--button-hover-bg); border-color: var(--button-hover-border); transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.07); }
        .tool-button.active { 
            background: var(--button-active-bg);
            color: var(--button-active-color); 
            border-color: var(--button-active-border);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            transform: translateY(-2px);
        }
        
        input[type="color"] { -webkit-appearance: none; width: 36px; height: 36px; border: 1px solid var(--border-color); padding: 0; border-radius: 50%; cursor: pointer; overflow: hidden; transition: transform 0.2s; }
        input[type="color"]:hover { transform: scale(1.1); }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
        input[type="range"] { cursor: pointer; width: 100px; }

        #theme-toggle svg { display: none; }
        body:not(.dark-mode) #theme-icon-light { display: block; }
        body.dark-mode #theme-icon-dark { display: block; }

        /* Canvas styling */
        .canvas-wrapper { position: relative; }
        canvas {
            cursor: crosshair; /* Default for shapes */
            display: block; background-color: var(--canvas-bg);
            transition: background-color 0.3s;
        }

        /* Custom Cursors for Tools */
        body:not(.dark-mode) .cursor-pencil { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z'></path></svg>") 4 20, auto; }
        body.dark-mode .cursor-pencil { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23f1f1f1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z'></path></svg>") 4 20, auto; }
        body:not(.dark-mode) .cursor-ink-pen { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='m17.5 2.5-15 15L6 21.5l15-15-3.5-4Z'/><path d='m14.5 5.5 3 3'/><path d='M5 19l-2.5 2.5'/></svg>") 4 20, auto; }
        body.dark-mode .cursor-ink-pen { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23f1f1f1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='m17.5 2.5-15 15L6 21.5l15-15-3.5-4Z'/><path d='m14.5 5.5 3 3'/><path d='M5 19l-2.5 2.5'/></svg>") 4 20, auto; }
        body:not(.dark-mode) .cursor-eraser { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21H7z'/><path d='M18 7.5l-4.5 4.5'/></svg>") 4 20, auto; }
        body.dark-mode .cursor-eraser { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23f1f1f1' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21H7z'/><path d='M18 7.5l-4.5 4.5'/></svg>") 4 20, auto; }

        /* Layers Panel Styling */
        #layers-panel {
            width: 220px;
            flex-shrink: 0;
            background-color: var(--container-bg);
            border-radius: 16px;
            box-shadow: 0 20px 40px var(--shadow-color);
            border: 1px solid var(--border-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: all 0.3s ease;
        }
        #layers-panel h3 { margin: 0 0 10px 0; font-size: 16px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px;}
        #layers-list { list-style: none; margin: 0; padding: 0; flex-grow: 1; }
        .layer-item { display: flex; align-items: center; gap: 8px; padding: 10px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, transform 0.2s; }
        .layer-item:hover { background-color: var(--button-hover-bg); transform: translateX(3px); }
        .layer-item.active { background: var(--button-active-bg); color: var(--button-active-color); }
        .layer-name { flex-grow: 1; font-weight: 500;}
        .layer-visibility, .delete-layer-btn { background: none; border: none; padding: 4px; cursor: pointer; color: var(--text-color-light); transition: color 0.2s; }
        .layer-item.active .layer-visibility, .layer-item.active .delete-layer-btn { color: var(--button-active-color); }
        .layer-visibility:hover, .delete-layer-btn:hover { color: var(--gradient-start); }
        .layer-item.active .layer-visibility:hover, .layer-item.active .delete-layer-btn:hover { color: rgba(255,255,255,0.8); }
        #layers-controls { display: flex; gap: 10px; border-top: 1px solid var(--border-color); padding-top: 10px; }
        #add-layer-btn { width: 100%; }

        /* --- RESPONSIVENESS --- */
        @media (max-width: 1200px) {
            .app-wrapper {
                flex-direction: column;
                width: 100%;
            }
            #layers-panel {
                width: 100%;
                box-sizing: border-box;
                order: 3; /* Move layers panel to the bottom */
            }
            .whiteboard-container {
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .toolbar {
                padding: 10px;
                gap: 10px;
            }
            .tool-group {
                padding-right: 10px;
                gap: 8px;
            }
            /* Hide labels on smaller tablets to save space */
            .tool-group label {
                display: none;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            .toolbar {
                padding: 8px;
                justify-content: center; /* Center the tool groups */
            }
            .tool-group {
                border-right: none; /* Remove all dividers */
                padding-right: 0;
            }
            /* Make the stroke preview smaller */
            #stroke-preview {
                width: 40px;
                height: 40px;
            }
            input[type="range"] {
                width: 70px; /* Further reduce slider width */
            }
            /* Adjust padding for smaller tap targets */
            .tool-button, .action-button, select {
                padding: 8px;
            }
        }
    </style>
</head>
<body>

    <div class="app-wrapper">
        <div class="whiteboard-container">
            <div class="toolbar">
                 <div class="tool-group">
                    <label for="board-switcher">Board:</label>
                    <select id="board-switcher"></select>
                    <button id="new-board-btn" class="action-button" title="New Board">+</button>
                    <button id="delete-board-btn" class="action-button" title="Delete Board">-</button>
                </div>
                <div class="tool-group">
                    <label>Tools:</label>
                    <button id="pencil-tool" class="tool-button active" title="Pencil (P)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z"/></svg></button>
                    <button id="ink-pen-tool" class="tool-button" title="Ink Pen (I)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M12.854.146a.5.5 0 0 0-.707 0L10.5 1.793 14.207 5.5l1.647-1.646a.5.5 0 0 0 0-.708l-3-3zM4.207 10.5l-3 3a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0-.708-.708zM14.5 5.793l-1.5-1.5-7.5 7.5-1.5 1.5-1.5-1.5 7.5-7.5 1.5-1.5-1.5-1.5L1.5 11.5l3 3L14.5 5.793z"/></svg></button>
                    <button id="eraser-tool" class="tool-button" title="Eraser (E)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828l6.879-6.879zm2.121.707a1 1 0 0 0-1.414 0L4.16 7.547l5.293 5.293 4.633-4.633a1 1 0 0 0 0-1.414l-3.879-3.879zM8.746 13.547 3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293l.16-.16z"/></svg></button>
                    <button id="rectangle-tool" class="tool-button" title="Rectangle (R)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/></svg></button>
                    <button id="circle-tool" class="tool-button" title="Circle (C)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/></svg></button>
                    <button id="line-tool" class="tool-button" title="Line (L)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M2 8a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11A.5.5 0 0 1 2 8Z"/></svg></button>
                </div>
                <div class="tool-group">
                    <label>Actions:</label>
                    <button id="undo-btn" class="action-button" title="Undo (Ctrl+Z)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466z"/></svg></button>
                    <button id="redo-btn" class="action-button" title="Redo (Ctrl+Y)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966a.25.25 0 0 1 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg></button>
                    <button id="clear-layer-btn" class="action-button" title="Clear Layer">Clear</button>
                    <button id="export-png" class="action-button" title="Export as PNG"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg> Export</button>
                </div>
                <div class="tool-group">
                    <label for="stroke-color">Color:</label>
                    <input type="color" id="stroke-color" value="#000000">
                </div>
                <div class="tool-group">
                    <label for="stroke-width">Size:</label>
                    <input type="range" id="stroke-width" min="1" max="50" value="5">
                    <div id="stroke-preview" style="width: 50px; height: 50px; border: 1px solid var(--border-color); border-radius: 6px; display: flex; justify-content: center; align-items: center; transition: all 0.2s ease;">
                        <div id="stroke-dot" style="width: 5px; height: 5px; border-radius: 50%; background-color: rgb(0, 0, 0); transition: all 0.2s ease;"></div>
                    </div>
                </div>
                <div class="tool-group" style="margin-left: auto;">
                    <button id="theme-toggle" class="action-button" title="Toggle Theme">
                        <svg id="theme-icon-light" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/></svg>
                        <svg id="theme-icon-dark" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/></svg>
                    </button>
                </div>
            </div>
            <div class="canvas-wrapper">
                <canvas id="whiteboard-canvas"></canvas>
            </div>
        </div>

        <div id="layers-panel">
            <h3>Layers</h3>
            <ul id="layers-list"></ul>
            <div id="layers-controls">
                <button id="add-layer-btn" class="action-button">Add Layer</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * Simple EventEmitter for pub/sub pattern (Publish/Subscribe).
         * This class allows different parts of the application to communicate
         * without being directly connected. One part 'emits' an event, and
         * any other part 'on' (listening for) that event will react.
         * This is great for keeping the code organized and decoupled.
         */
        class EventEmitter {
            constructor() {
                this.events = {};
            }

            /**
             * Subscribe to an event.
             * @param {string} eventName - The name of the event to listen for.
             * @param {Function} listener - The callback function to execute when the event is emitted.
             */
            on(eventName, listener) {
                if (!this.events[eventName]) {
                    this.events[eventName] = [];
                }
                this.events[eventName].push(listener);
            }

            /**
             * Publish an event.
             * @param {string} eventName - The name of the event to emit.
             * @param  {...any} args - Any arguments to pass to the listeners.
             */
            emit(eventName, ...args) {
                if (this.events[eventName]) {
                    this.events[eventName].forEach(listener => listener(...args));
                }
            }
        }

        /**
         * Manages all interactions with the browser's localStorage.
         * This class centralizes the logic for saving and loading data,
         * making it easy to manage how the application state is persisted.
         */
        class Storage {
            /**
             * Retrieves an item from localStorage and parses it as JSON.
             * @param {string} key - The key of the item to retrieve.
             * @returns {any | null} The parsed data or null if not found.
             */
            get(key) {
                try {
                    const item = localStorage.getItem(key);
                    return item ? JSON.parse(item) : null;
                } catch (e) {
                    // If it's not valid JSON, return it as a plain string.
                    return localStorage.getItem(key);
                }
            }

            /**
             * Saves an item to localStorage. Converts objects to JSON strings.
             * @param {string} key - The key under which to store the value.
             * @param {any} value - The value to store.
             */
            set(key, value) {
                const valueToStore = typeof value === 'object' ? JSON.stringify(value) : value;
                localStorage.setItem(key, valueToStore);
            }
        }

        /**
         * Handles the UI and logic for the toolbar.
         * It listens for user clicks on buttons and emits events
         * to notify the rest of the application about the user's actions.
         */
        class Toolbar extends EventEmitter {
            constructor() {
                super();
                // Store references to all the toolbar's HTML elements for easy access.
                this.elements = {
                    boardSwitcher: document.getElementById('board-switcher'),
                    newBoardBtn: document.getElementById('new-board-btn'),
                    deleteBoardBtn: document.getElementById('delete-board-btn'),
                    colorPicker: document.getElementById('stroke-color'),
                    widthSlider: document.getElementById('stroke-width'),
                    clearLayerBtn: document.getElementById('clear-layer-btn'),
                    undoBtn: document.getElementById('undo-btn'),
                    redoBtn: document.getElementById('redo-btn'),
                    toolButtons: document.querySelectorAll('.tool-button'),
                    themeToggle: document.getElementById('theme-toggle'),
                    exportBtn: document.getElementById('export-png'),
                    strokeDot: document.getElementById('stroke-dot'),
                };
                this.initListeners();
            }

            /**
             * Sets up all the event listeners for the toolbar elements.
             * When a user interacts with an element, this class emits a corresponding event.
             */
            initListeners() {
                // Tool selection
                this.elements.toolButtons.forEach(b => b.addEventListener('click', () => this.emit('tool:change', b.id.replace('-tool', ''))));
                
                // Color and width changes
                this.elements.colorPicker.addEventListener('change', (e) => this.emit('color:change', e.target.value));
                this.elements.widthSlider.addEventListener('input', (e) => this.emit('width:change', e.target.value));
                
                // Action buttons
                this.elements.undoBtn.addEventListener('click', () => this.emit('history:undo'));
                this.elements.redoBtn.addEventListener('click', () => this.emit('history:redo'));
                this.elements.clearLayerBtn.addEventListener('click', () => this.emit('layer:clear'));
                
                // Board management
                this.elements.boardSwitcher.addEventListener('change', (e) => this.emit('board:switch', e.target.value));
                this.elements.newBoardBtn.addEventListener('click', () => this.emit('board:new'));
                this.elements.deleteBoardBtn.addEventListener('click', () => this.emit('board:delete'));

                // App-level actions
                this.elements.exportBtn.addEventListener('click', () => this.emit('app:export'));
                this.elements.themeToggle.addEventListener('click', () => this.emit('theme:toggle'));
            }
            
            /**
             * Enables or disables the undo/redo buttons based on the history state.
             * @param {{canUndo: boolean, canRedo: boolean}} historyState - The current state of the history.
             */
            updateHistoryButtons({ canUndo, canRedo }) {
                this.elements.undoBtn.disabled = !canUndo;
                this.elements.redoBtn.disabled = !canRedo;
            }

            /**
             * Fills the board switcher dropdown with the available boards.
             * @param {Array<Object>} boards - An array of board objects.
             * @param {string} activeBoardId - The ID of the currently active board.
             */
            populateBoardSwitcher(boards, activeBoardId) {
                this.elements.boardSwitcher.innerHTML = boards.map(b => `<option value="${b.id}">${b.name}</option>`).join('');
                this.elements.boardSwitcher.value = activeBoardId;
                // You can't delete the last board.
                this.elements.deleteBoardBtn.disabled = boards.length <= 1;
            }

            /**
             * Updates the UI to show which tool is currently active.
             * @param {string} toolName - The name of the tool to activate (e.g., 'pencil').
             */
            selectTool(toolName) {
                this.elements.toolButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.id === `${toolName}-tool`);
                });
            }

            /**
             * Updates the stroke preview dot to show the current color and size.
             * @param {{color: string, width: number}} strokeOptions - The current stroke options.
             */
            updateStrokePreview({ color, width }) {
                this.elements.strokeDot.style.backgroundColor = color;
                this.elements.strokeDot.style.width = `${width}px`;
                this.elements.strokeDot.style.height = `${width}px`;
            }
        }

        /**
         * Manages all the data for boards and layers, including their state and history (for undo/redo).
         * It also controls the Layers Panel UI.
         */
        class LayerManager extends EventEmitter {
            constructor(storage) {
                super();
                this.storage = storage;
                this.boards = [];
                this.activeBoardId = null;
                this.activeLayerId = null;
                // Store references to the layer panel's HTML elements.
                this.elements = {
                    layersList: document.getElementById('layers-list'),
                    addLayerBtn: document.getElementById('add-layer-btn'),
                };
                this.init();
                this.initListeners();
            }

            /**
             * Initializes the LayerManager by loading data from storage.
             * If no data exists, it creates a default board.
             */
            init() {
                this.boards = this.storage.get('whiteboards') || [];
                this.activeBoardId = this.storage.get('activeBoardId');

                if (this.boards.length === 0) {
                    this.createNewBoard('My First Board', false); // Create a board without prompting
                } else {
                    this.migrateOldData(); // Check if data is from an older version
                }
                
                // If the stored active board doesn't exist anymore, select the first one.
                if (!this.boards.find(b => b.id === this.activeBoardId)) {
                    this.activeBoardId = this.boards[0]?.id;
                }
                
                this.loadBoard(this.activeBoardId);
            }

            /**
             * Sets up event listeners for the layer panel.
             */
            initListeners() {
                this.elements.addLayerBtn.addEventListener('click', this.addNewLayer.bind(this));
                // Use event delegation for clicks within the layers list.
                this.elements.layersList.addEventListener('click', this.handleLayerClick.bind(this));
            }
            
            /**
             * This function handles migrating data from a previous version of the app
             * that didn't have a layer system. It converts old board data into the new layer format.
             */
            migrateOldData() {
                let wasMigrated = false;
                this.boards.forEach(board => {
                    if (!board.layers) { // If a board object doesn't have a 'layers' property, it's old data.
                       const layer = this.createLayerObject('Layer 1', board.data);
                       if (board.data) {
                           layer.history.push(board.data);
                           layer.historyIndex = 0;
                       }
                       board.layers = [layer]; // Create a new layers array
                       board.activeLayerId = layer.id;
                       delete board.data; // Remove the old data property
                       wasMigrated = true;
                    }
                });
                if(wasMigrated) this.save(); // Save the migrated data.
            }

            // Helper functions to get the current active board and layer objects.
            getActiveBoard = () => this.boards.find(b => b.id === this.activeBoardId);
            getActiveLayer = () => this.getActiveBoard()?.layers.find(l => l.id === this.activeLayerId);
            
            /**
             * Loads a specific board, making it the active one.
             * @param {string} boardId - The ID of the board to load.
             */
            loadBoard(boardId) {
                const board = this.boards.find(b => b.id === boardId);
                if (board) {
                    this.activeBoardId = boardId;
                    this.activeLayerId = board.activeLayerId || board.layers[0]?.id;
                    this.storage.set('activeBoardId', this.activeBoardId);
                    this.emit('manager:updated'); // Notify the app that the state has changed.
                }
            }
            
            /**
             * Creates a new whiteboard.
             * @param {string} name - The default name for the new board.
             * @param {boolean} [shouldPrompt=true] - Whether to ask the user for a name.
             */
            createNewBoard(name, shouldPrompt = true) {
                const boardName = shouldPrompt ? prompt("New board name:", name) : name;
                if (boardName) {
                    const firstLayer = this.createLayerObject('Layer 1');
                    const newBoard = { id: Date.now().toString(), name: boardName, layers: [firstLayer], activeLayerId: firstLayer.id };
                    this.boards.push(newBoard);
                    this.loadBoard(newBoard.id);
                    this.save();
                }
            }

            /**
             * Deletes the currently active board.
             */
            deleteActiveBoard() {
                if (this.boards.length > 1 && confirm(`Delete board "${this.getActiveBoard().name}"?`)) {
                    this.boards = this.boards.filter(b => b.id !== this.activeBoardId);
                    this.loadBoard(this.boards[0].id); // Load the first remaining board
                    this.save();
                }
            }

            /**
             * Adds a new layer to the current board.
             */
            addNewLayer() {
                const board = this.getActiveBoard();
                if (board) {
                    const layerName = prompt('New layer name:', `Layer ${board.layers.length + 1}`);
                    if (layerName) {
                        const newLayer = this.createLayerObject(layerName);
                        board.layers.push(newLayer);
                        this.activeLayerId = newLayer.id; // Make the new layer active
                        board.activeLayerId = this.activeLayerId;
                        this.save();
                        this.emit('manager:updated');
                    }
                }
            }
            
            /**
             * Creates a standard layer object.
             * @param {string} name - The name of the layer.
             * @param {string | null} [data=null] - The initial image data for the layer.
             * @returns {Object} A new layer object.
             */
            createLayerObject(name, data = null) {
                return { id: Date.now().toString(), name, isVisible: true, data, history: [], historyIndex: -1 };
            }

            /**
             * Handles all click events on the layers list (select, toggle visibility, delete).
             * @param {Event} e - The click event object.
             */
            handleLayerClick(e) {
                const layerItem = e.target.closest('.layer-item');
                if (!layerItem) return;

                const layerId = layerItem.dataset.id;
                const board = this.getActiveBoard();
                const layer = board.layers.find(l => l.id === layerId);

                if (e.target.matches('.layer-visibility, .layer-visibility *')) { // Check for clicks on the visibility button or its children (emoji)
                    layer.isVisible = !layer.isVisible;
                } else if (e.target.matches('.delete-layer-btn, .delete-layer-btn *')) {
                    this.deleteLayer(layerId);
                } else {
                    // If the click was on the item itself, make it the active layer.
                    this.activeLayerId = layerId;
                    board.activeLayerId = layerId;
                }
                this.save();
                this.emit('manager:updated');
            }
            
            /**
             * Deletes a specific layer from the current board.
             * @param {string} layerId - The ID of the layer to delete.
             */
            deleteLayer(layerId) {
                const board = this.getActiveBoard();
                if (board.layers.length > 1) { // Prevent deleting the last layer.
                    const layer = board.layers.find(l => l.id === layerId);
                    if (confirm(`Delete layer "${layer.name}"?`)) {
                        board.layers = board.layers.filter(l => l.id !== layerId);
                        // If the deleted layer was the active one, make the last layer in the list active.
                        if (this.activeLayerId === layerId) {
                            this.activeLayerId = board.layers[board.layers.length-1].id;
                            board.activeLayerId = this.activeLayerId;
                        }
                    }
                } else {
                    alert('Cannot delete the last layer.');
                }
            }
            
            /**
             * Updates the image data for the active layer and manages the history stack for undo/redo.
             * @param {string} dataUrl - The new image data as a base64 Data URL.
             */
            updateActiveLayerData(dataUrl) {
                const layer = this.getActiveLayer();
                if (layer) {
                    // If we are undoing and then draw something new, we need to clear the "redo" history.
                    if (layer.historyIndex < layer.history.length - 1) {
                        layer.history.splice(layer.historyIndex + 1);
                    }
                    layer.history.push(dataUrl);
                    layer.historyIndex++;
                    layer.data = dataUrl; // Update the current view
                    this.save();
                    this.emit('manager:updated'); // Notify the app to update UI (like undo/redo buttons)
                }
            }
            
            /**
             * Reverts the active layer to its previous state in the history.
             */
            undo() {
                const layer = this.getActiveLayer();
                if (layer && layer.historyIndex > 0) {
                    layer.historyIndex--;
                    layer.data = layer.history[layer.historyIndex];
                    this.save();
                    this.emit('manager:updated'); // Notify the app to re-render the canvas
                }
            }

            /**
             * Re-applies a state that was previously undone.
             */
            redo() {
                const layer = this.getActiveLayer();
                if (layer && layer.historyIndex < layer.history.length - 1) {
                    layer.historyIndex++;
                    layer.data = layer.history[layer.historyIndex];
                    this.save();
                    this.emit('manager:updated');
                }
            }
            
            /**
             * Clears all drawing from the active layer and resets its history.
             */
            clearActiveLayer() {
                const layer = this.getActiveLayer();
                if(layer && confirm(`Clear all content from layer "${layer.name}"?`)) {
                    layer.data = null; // No image data
                    layer.history = []; // Empty history
                    layer.historyIndex = -1;
                    this.save();
                    this.emit('manager:updated');
                }
            }

            /**
             * Renders the list of layers in the Layers Panel UI.
             */
            renderUI() {
                const board = this.getActiveBoard();
                if (!board) return;
                this.elements.layersList.innerHTML = ''; // Clear the current list
                // Create and append an HTML list item for each layer.
                board.layers.forEach(layer => {
                    const li = document.createElement('li');
                    li.className = `layer-item ${layer.id === this.activeLayerId ? 'active' : ''}`;
                    li.dataset.id = layer.id;
                    li.innerHTML = `
                        <span class="layer-name">${layer.name}</span>
                        <button class="layer-visibility" title="Toggle Visibility">${layer.isVisible ? 'üëÅÔ∏è' : 'üôà'}</button>
                        <button class="delete-layer-btn" title="Delete Layer">üóëÔ∏è</button>
                    `;
                    // Prepend so the newest layers appear at the top.
                    this.elements.layersList.prepend(li);
                });
            }

            /**
             * Saves the entire boards data structure to localStorage.
             */
            save = () => this.storage.set('whiteboards', this.boards);
        }
        
        /**
         * Manages the <canvas> element, all drawing logic, and rendering of layers.
         */
        class WhiteboardCanvas {
            constructor(layerManager) {
                this.layerManager = layerManager;
                this.canvas = document.getElementById('whiteboard-canvas');
                // The 'context' is the object we use to draw on the canvas.
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });

                this.isDrawing = false;
                // This 'state' object holds all the current drawing settings.
                this.state = {
                    tool: 'pencil',
                    color: '#000000',
                    width: 5,
                    startX: 0,
                    startY: 0,
                    snapshot: null, // A snapshot of the canvas before a new shape is drawn
                };
                
                this.initListeners();
            }

            /**
             * Sets up mouse event listeners on the canvas.
             */
            initListeners() {
                this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                this.canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                this.canvas.addEventListener('mouseout', this.stopDrawing.bind(this)); // Stop if mouse leaves canvas
                this.canvas.addEventListener('mousemove', this.draw.bind(this));
            }

            /**
             * Sets the active drawing tool and updates the cursor style.
             * @param {string} tool - The tool to set (e.g., 'pencil', 'eraser').
             */
            setTool(tool) {
                this.state.tool = tool;
                document.body.classList.remove('cursor-pencil', 'cursor-eraser', 'cursor-ink-pen');
                if (tool === 'pencil') document.body.classList.add('cursor-pencil');
                else if (tool === 'eraser') document.body.classList.add('cursor-eraser');
                else if (tool === 'ink-pen') document.body.classList.add('cursor-ink-pen');
            }
            
            /**
             * Called when the user presses the mouse button down on the canvas.
             * @param {MouseEvent} e - The mouse event.
             */
            startDrawing(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.isDrawing = true;
                this.state.startX = e.clientX - rect.left;
                this.state.startY = e.clientY - rect.top;

                // Save the current state of the canvas. This is crucial for drawing shapes
                // like rectangles and circles, as it allows us to redraw the shape from a
                // clean slate on each mouse move.
                this.state.snapshot = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);

                // Configure drawing properties
                this.ctx.beginPath(); // Start a new path
                this.ctx.moveTo(this.state.startX, this.state.startY);
                this.ctx.lineWidth = this.state.width;
                this.ctx.strokeStyle = this.state.color;
                
                // Different tools have different line styles.
                if (this.state.tool === 'ink-pen') {
                    this.ctx.lineCap = 'butt';
                    this.ctx.lineJoin = 'miter';
                } else {
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                }
            }

            /**
             * Called when the user releases the mouse button or moves the mouse off the canvas.
             */
            stopDrawing() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.ctx.beginPath(); // Reset the path
                    this.saveLayerState(); // Save the final drawing to the layer's history
                }
            }

            /**
             * Called whenever the user moves the mouse while holding the button down.
             * @param {MouseEvent} e - The mouse event.
             */
            draw(e) {
                if (!this.isDrawing) return;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // For shapes, restore the canvas to its state before we started drawing this shape.
                this.ctx.putImageData(this.state.snapshot, 0, 0);
                
                // The 'eraser' works by making pixels transparent ('destination-out').
                // All other tools draw on top of what's there ('source-over').
                this.ctx.globalCompositeOperation = (this.state.tool === 'eraser') ? 'destination-out' : 'source-over';
                this.ctx.strokeStyle = (this.state.tool === 'eraser') ? 'rgba(0,0,0,1)' : this.state.color;
                
                // Handle drawing for each specific tool.
                switch(this.state.tool) {
                    case 'pencil': 
                    case 'eraser': 
                    case 'ink-pen':
                        this.ctx.lineTo(x,y); 
                        this.ctx.stroke(); 
                        break;
                    case 'rectangle': 
                        this.ctx.beginPath(); 
                        this.ctx.strokeRect(this.state.startX, this.state.startY, x - this.state.startX, y - this.state.startY); 
                        break;
                    case 'circle': 
                        const r = Math.hypot(x - this.state.startX, y - this.state.startY); 
                        this.ctx.beginPath(); 
                        this.ctx.arc(this.state.startX, this.state.startY, r, 0, 2 * Math.PI); 
                        this.ctx.stroke(); 
                        break;
                    case 'line': 
                        this.ctx.beginPath(); 
                        this.ctx.moveTo(this.state.startX, this.state.startY); 
                        this.ctx.lineTo(x, y); 
                        this.ctx.stroke(); 
                        break;
                }
            }
            
            /**
             * Saves the current drawing on the canvas to the active layer's data.
             * This function is now using async/await for cleaner, more readable code.
             */
            async saveLayerState() {
                const layer = this.layerManager.getActiveLayer();
                if (!layer) return;

                // Create an in-memory (offscreen) canvas to merge the previous layer state
                // with the new drawing, without causing a flicker on the main canvas.
                const offscreenCanvas = new OffscreenCanvas(this.canvas.width, this.canvas.height);
                const offscreenCtx = offscreenCanvas.getContext('2d');
                
                // 1. Draw the previous state of the layer onto the offscreen canvas.
                if (layer.data) {
                    const img = new Image();
                    await new Promise(resolve => {
                        img.onload = resolve;
                        img.onerror = resolve; // Continue even if the old image fails to load
                        img.src = layer.data;
                    });
                    offscreenCtx.drawImage(img, 0, 0);
                }

                // 2. Draw the new strokes (currently on the main canvas) on top of it.
                offscreenCtx.drawImage(this.canvas, 0, 0);

                // 3. Convert the merged image to a PNG blob and then to a Data URL.
                const blob = await offscreenCanvas.convertToBlob({ type: 'image/png' });
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onload = () => {
                    // 4. Update the layer manager with the new data URL.
                    this.layerManager.updateActiveLayerData(reader.result);
                };
            }

            /**
             * Renders all visible layers of the current board onto the canvas.
             */
            async render() {
                // Clear the entire canvas before redrawing.
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const board = this.layerManager.getActiveBoard();
                if (!board) return;

                // Get all layers that are marked as visible.
                const visibleLayers = board.layers.filter(l => l.isVisible);
                for (const layer of visibleLayers) {
                    if (layer.data) { // If the layer has image data...
                        try {
                            const blob = await (await fetch(layer.data)).blob();
                            if (blob.size > 0) {
                                const img = await createImageBitmap(blob);
                                this.ctx.drawImage(img, 0, 0); // ...draw it on the canvas.
                            }
                        } catch(e) {
                            console.error("Could not render layer:", e);
                        }
                    }
                }
            }
            
            /**
             * Resizes the canvas to fit its container and then re-renders the content.
             */
            resize() {
                const container = document.querySelector('.whiteboard-container');
                this.canvas.width = container.clientWidth;
                this.canvas.height = Math.max(400, window.innerHeight - container.querySelector('.toolbar').offsetHeight - 80);
                this.render();
            }
        }
        
        /**
         * Main Application Class.
         * This class initializes all the other components (Toolbar, LayerManager, Canvas)
         * and connects them so they can communicate with each other. It's the "brain" of the application.
         */
        class App {
            constructor() {
                this.storage = new Storage();
                this.toolbar = new Toolbar();
                this.layerManager = new LayerManager(this.storage);
                this.canvas = new WhiteboardCanvas(this.layerManager);
                
                this.init();
                this.connectComponents();
            }
            
            /**
             * Performs initial setup tasks when the application starts.
             */
            init() {
                // Load the theme (light/dark) from storage.
                this.setTheme(this.storage.get('whiteboardTheme') || 'light');
                this.canvas.resize();
                this.updateUI();
                 // Set the initial state of the stroke preview.
                this.toolbar.updateStrokePreview({
                    color: this.canvas.state.color,
                    width: this.canvas.state.width
                });
            }

            /**
             * Wires up all the event listeners between the components.
             * This is where the event-driven architecture comes together.
             */
            connectComponents() {
                // Listen for events from the Toolbar
                this.toolbar.on('tool:change', tool => {
                    this.canvas.setTool(tool);
                    this.toolbar.selectTool(tool);
                });
                this.toolbar.on('color:change', color => {
                    this.canvas.state.color = color;
                    this.toolbar.updateStrokePreview({ color, width: this.canvas.state.width });
                });
                this.toolbar.on('width:change', width => {
                    this.canvas.state.width = width;
                    this.toolbar.updateStrokePreview({ color: this.canvas.state.color, width });
                });
                this.toolbar.on('history:undo', () => this.layerManager.undo());
                this.toolbar.on('history:redo', () => this.layerManager.redo());
                this.toolbar.on('layer:clear', () => this.layerManager.clearActiveLayer());
                this.toolbar.on('board:switch', id => this.layerManager.loadBoard(id));
                this.toolbar.on('board:new', () => this.layerManager.createNewBoard(`Board ${this.layerManager.boards.length + 1}`));
                this.toolbar.on('board:delete', () => this.layerManager.deleteActiveBoard());
                this.toolbar.on('app:export', this.exportAsPNG.bind(this));
                this.toolbar.on('theme:toggle', () => this.setTheme(document.body.classList.contains('dark-mode') ? 'light' : 'dark'));

                // Listen for events from the LayerManager
                this.layerManager.on('manager:updated', this.updateUI.bind(this));

                // Listen for global browser events
                window.addEventListener('resize', () => this.canvas.resize());
                window.addEventListener('keydown', this.handleKeyPress.bind(this));
            }

            /**
             * A central function to update all parts of the UI that depend on the application's state.
             */
            updateUI() {
                this.canvas.render();
                this.layerManager.renderUI();
                this.toolbar.populateBoardSwitcher(this.layerManager.boards, this.layerManager.activeBoardId);
                const activeLayer = this.layerManager.getActiveLayer();
                this.toolbar.updateHistoryButtons({
                    canUndo: activeLayer && activeLayer.historyIndex > 0,
                    canRedo: activeLayer && activeLayer.historyIndex < activeLayer.history.length - 1,
                });
            }

            /**
             * Sets the color theme for the application.
             * @param {'light' | 'dark'} theme - The theme to apply.
             */
            setTheme(theme) {
                this.storage.set('whiteboardTheme', theme);
                document.body.classList.toggle('dark-mode', theme === 'dark');
            }
            
            /**
             * Exports the current view of the canvas as a high-resolution PNG file.
             */
            async exportAsPNG() {
                const scaleFactor = 2; // Export at 2x resolution for better quality
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.canvas.canvas.width * scaleFactor;
                tempCanvas.height = this.canvas.canvas.height * scaleFactor;
                
                // Fill the background of the exported image with the current canvas background color.
                tempCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--canvas-bg').trim();
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.imageSmoothingEnabled = true;

                // Draw all visible layers onto the temporary canvas.
                const board = this.layerManager.getActiveBoard();
                if (!board) return;

                const visibleLayers = board.layers.filter(l => l.isVisible);
                for (const layer of visibleLayers) {
                    if (layer.data) {
                        const img = new Image();
                        // We must wait for each layer's image to load before drawing it.
                        await new Promise(resolve => {
                            img.onload = () => { 
                                tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height); 
                                resolve(); 
                            };
                            img.onerror = resolve; // Don't let a broken image stop the export.
                            img.src = layer.data;
                        });
                    }
                }
                
                // Create a temporary link element to trigger the download.
                const link = document.createElement('a');
                link.download = `${board.name.replace(/\s+/g, '_')}-export.png`;
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
            }

            /**
             * Handles global keyboard shortcuts for tools and actions.
             * @param {KeyboardEvent} e - The keyboard event.
             */
            handleKeyPress(e) {
                // Ignore key presses if the user is typing in an input field.
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                // Undo (Ctrl+Z) and Redo (Ctrl+Y)
                if (e.ctrlKey || e.metaKey) { // metaKey is for Command on macOS
                    if (e.key.toLowerCase() === 'z') { e.preventDefault(); this.layerManager.undo(); }
                    if (e.key.toLowerCase() === 'y') { e.preventDefault(); this.layerManager.redo(); }
                } else {
                    // Tool shortcuts (P for Pencil, E for Eraser, etc.)
                    const toolMap = { p: 'pencil', i: 'ink-pen', e: 'eraser', r: 'rectangle', c: 'circle', l: 'line' };
                    if (toolMap[e.key.toLowerCase()]) {
                        this.toolbar.emit('tool:change', toolMap[e.key.toLowerCase()]);
                    }
                }
            }
        }
        
        // This ensures the script runs only after the entire HTML document has been loaded.
        document.addEventListener('DOMContentLoaded', () => {
            const app = new App();
        });
    </script>
</body>
</html>